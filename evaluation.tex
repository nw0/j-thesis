\documentclass[thesis.tex]{subfile}

\chapter{Evaluation}
\label{ch:evaluation}

This chapter is devoted to the evaluation of performance of time-tiling as implemented in Chapter~\ref{ch:implementation}.
We discuss the functionality of the time-tiling implementation and its technical requirements (Section~\ref{sec:time-tiling-reqs}), and the test methodology (Section~\ref{sec:test-method}).
Section~\ref{sec:perf-laplace} examines results under the Laplacian operator.
Finally, we discuss limitations of testing (Section~\ref{sec:perf-limitations}), and consider further work in evaluation (Section~\ref{sec:further-eval}).


\section{Pre-requisites for time-tiling}
\label{sec:time-tiling-reqs}

As time-tiling has been implemented within Devito, there is no need for any external tool such as a polyhedral compiler.
Nevertheless, some attention must be paid to configuration when using time-tiling, as follows.

\subsection{Time-buffering}
% Time buffering and save=n>2*time tile size (a nice diagram!)
Time-buffering is a memory saving technique.

\begin{figure}[!ht]
\begin{lstlisting}
for (int t = t_s; t < t_e; t++)
  for (int x = x_s; x < x_e; x++)
    A[t][x] = A[t-1][x] + A[t-2][x] + ... + A[t-n][x];
\end{lstlisting}
	\caption{A stencil with a value depending on data in the previous \(n\) time iterations. \(n\) is usually small compared to the problem domain, \texttt{t\_e - t\_s + n} here.}
	\label{lst:buffer-eg}
\end{figure}

A stencil may only have dependencies on data from finitely many previous time iterations.
Consider a stencil with a data dependence on the last \(n\) time iterations (Figure~\ref{lst:buffer-eg}).
It is clear that whenever \(t \ge n+1\), data from the \(t=0\) iteration is not required.

When space-tiling in Devito, each time iteration only begins once the previous has finished.
Therefore, we only need to store \(n+1\) time iterations of data: the current iteration being computed; and the previous \(n\) iterations, its dependencies.

% TODO: a diagram explaining the footnote? (promote the footnote)
To allow for rigorous correctness checks (Section~\ref{sec:eval-func-corr}), we have \emph{not} used time-buffering during the evaluation.
Nevertheless, it is an easy exercise that for time-tiling to perform better than spatial tiling, at least \(n+2\) time iterations must be stored.\footnote{From a synchronisation perspective, this would be extremely challenging. It is fairly clear that time-tiling needs at most \(2n+1\) time iterations of storage, and we would recommend this approach.}

\subsection{Auto-tuner iterations}
% Further prereqs to use the AT
Previously covered in Section~\ref{sec:autotune}, the Devito auto-tuner experimentally searches for tile sizes achieving the lowest runtime.
To do this, it needs to store some time iterations of computations: this value is governed by a parameter.\footnote{The \texttt{at\_squeezer} parameter is the number of iterations that are computed, therefore requiring \(n + \texttt{at\_squeezer}\) time iterations of storage.}

For its results to be meaningful, we need to compute enough time iterations to try large time tile sizes.
Without time-tiling, a fairly small number of time iterations (4) sufficed for auto-tuning.
In our evaluation, we decided that the largest desirable time tile size was 16, to which we set the parameter.

\subsection{Time-tiling parameters}
Time-tiling requires more parameters: a valid skewing factor, and a tile size for the time dimension.
The tile size search was integrated into the auto-tuner, as it already had functionality to search for spatial tile sizes.
% TODO: evidence??
Arguments on data alignment give that the minimum valid skewing factor would produce the lowest runtime computation.
% TODO: go back and write what a valid skewing factor is
It was decided to try skewing factors by hand, as their validity would depend on the stencil (Section TODO).
% TODO: write this up
We have found that that the data alignment argument holds for the experiments that we have performed (see Appendix TODO for the complete results).


\section{Testing methodology}
\label{sec:test-method}

% Tern, openmp, icc, cat envs
% Usage of AT -- parameters (skewing factor, time and space tile sizes)
% Discuss roofline model

\subsection{Functional correctness}
\label{sec:eval-func-corr}


\section{Performance under the Laplace operator}
\label{sec:perf-laplace}


\section{Limitations of performance evaluation}
\label{sec:perf-limitations}


\section{Further evaluation}
\label{sec:further-eval}


\paragraph{BREAK}
Everything that follows here is old.

Previous evaluation suggested that Devito gains considerable speedup from time-tiling.
This chapter focusses on evaluating this statement with general time-tiling implemented in Devito.

\paragraph{Objective}
We want to evaluate the performance of the time-tiling transformation against that of tiling only in the other dimensions.


\section{Functional correctness}
This will be done primarily using test cases, some of which have already been written to test the features already implemented.
Where possible, existing test cases are reused, when the output is expected not to vary.

Additionally, while Devito is targeted at seismic imaging, it can also be used to apply finite-difference methods to general differential equations.
We are therefore able to perform testing against many natural examples, rather than being dependent on hand-crafted stencils.


\section{Initial performance evaluation}
The initial evaluation was completed using a machine in the Department of Computing Student Lab (\texttt{graphic12}).
We used an iteration space of dimensions \(384^3\) under a Laplacian operator, larger than the cache size to ensure that the tiling functionality was utilised.
A 30.7\% decrease in runtime was recorded with the Intel C++ Compiler (31.5\% under GCC) over 30 runs.

We will perform evaluation against a variety of stencils, including the acoustic wave equation (AWE) stencil used in~\cite{dylan}.
In all cases, consideration will be necessary to deal with time-dimension buffering.
This evaluation would comprise both timing and memory usage, as well as examining the loop structures of the generated code.

For a more in depth analysis, we would consider memory analyses measuring cache misses and memory traffic, to ensure that improvements are indeed gleaned from time-tiling rather than other factors.


\section{Extended evaluation}
As mentioned above, Devito gives rise to many natural test cases.
Implementation and time permitting, we could evaluate the benefit of time-tiling against a plethora of problems, such as inversion, or other operator orderings.
