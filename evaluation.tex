\documentclass[thesis.tex]{subfile}

\chapter{Evaluation}
\label{ch:evaluation}

This chapter is devoted to the evaluation of performance of time-tiling as implemented in Chapter~\ref{ch:implementation}.
We discuss the functionality of the time-tiling implementation and its technical requirements (Section~\ref{sec:time-tiling-reqs}), and the test methodology (Section~\ref{sec:test-method}).
Section~\ref{sec:perf-laplace} examines results under the Laplacian operator.
Finally, we discuss limitations of testing (Section~\ref{sec:perf-limitations}), and consider further work in evaluation (Section~\ref{sec:further-eval}).


\section{Motivation}
The motivation for this project is to reduce computational runtime by exploiting data locality through time-tiling.
We have described the motivation and investigated tools which have achieve performance gains from the technique.
It had previously been shown that Devito benefits from reductions in runtime of up to 27.5\% with time-tiling using CLooG.

Chapter~\ref{ch:implementation} described our implementation of time-tiling in Devito.
The objective of this evaluation are as follows:

\begin{itemize}
	\item Measure the performance gain against spatially-tiled computation;
	\item Verify any requirements to perform time-tiling effectively;
	\item Determine procedures and heuristics to identify the best-performing parameters for time-tiling;
	\item Additional verification of correctness, and margin of error introduced against non-tiled code\footnote{For example, due to non-associativity of floating-point arithmetic.}, if any.
\end{itemize}


\section{Pre-requisites for time-tiling}
\label{sec:time-tiling-reqs}

As time-tiling has been implemented within Devito, there is no need for any external tool such as a polyhedral compiler.
Nevertheless, some attention must be paid to configuration when using time-tiling, as follows.

\subsection{Time-buffering}
% Time buffering and save=n>2*time tile size (a nice diagram!)
Time-buffering is a memory saving technique.

\begin{figure}[!ht]
\begin{lstlisting}
for (int t = t_s; t < t_e; t++)
  for (int x = x_s; x < x_e; x++)
    A[t][x] = A[t-1][x] + A[t-2][x] + ... + A[t-n][x];
\end{lstlisting}
	\caption{A stencil with a value depending on data in the previous \(n\) time iterations. \(n\) is usually small compared to the problem domain, \texttt{t\_e - t\_s + n} here.}
	\label{lst:buffer-eg}
\end{figure}

A stencil may only have dependencies on data from finitely many previous time iterations.
Consider a stencil with a data dependence on the last \(n\) time iterations (Figure~\ref{lst:buffer-eg}).
It is clear that whenever \(t \ge n+1\), data from the \(t=0\) iteration is not required.

When space-tiling in Devito, each time iteration only begins once the previous has finished.
Therefore, we only need to store \(n+1\) time iterations of data: the current iteration being computed; and the previous \(n\) iterations, its dependencies.

% TODO: a diagram explaining the footnote? (promote the footnote)
To allow for rigorous correctness checks (Section~\ref{sec:eval-func-corr}), we have \emph{not} used time-buffering during the evaluation.
Nevertheless, it is clear to see that for time-tiling to perform better than spatial tiling, at least \(n+2\) time iterations must be stored.\footnote{From a synchronisation perspective, this would be extremely challenging. It is a fairly simple exercise to show that time-tiling needs at most \(n+t\) time iterations of storage, where \(t\) is the size of a time tile, and we would recommend this approach.}

\subsection{Auto-tuner iterations}
% Further prereqs to use the AT
Previously covered in Section~\ref{sec:autotune}, the Devito auto-tuner experimentally searches for tile sizes achieving the lowest runtime.
To do this, it needs to store some time iterations of computations: this value is governed by a parameter.\footnote{The \texttt{at\_squeezer} parameter is the number of iterations that are computed, therefore requiring \(n + \texttt{at\_squeezer}\) time iterations of storage.}

For its results to be meaningful, we need to compute enough time iterations to try large time tile sizes.
Without time-tiling, a fairly small number of time iterations (4) sufficed for auto-tuning.
In our evaluation, we decided that the largest desirable time tile size was 16, to which we set the parameter.

\subsection{Time-tiling parameters}
Time-tiling requires more parameters: a valid skewing factor, and a tile size for the time dimension.
The tile size search was integrated into the auto-tuner, as it already had functionality to search for spatial tile sizes.
% TODO: evidence??
Arguments on data alignment give that the minimum valid skewing factor would produce the lowest runtime computation.
% TODO: go back and write what a valid skewing factor is
It was decided to try skewing factors by hand, as their validity would depend on the stencil (Section TODO).
% TODO: write this up
We have found that that the data alignment argument holds for the experiments that we have performed (see Appendix TODO for the complete results).


\section{Testing methodology}
\label{sec:test-method}

Realistic test cases vary from those that are more memory-intensive to those that are more computationally intensive on a given hardware configuration.
Under the former regime, computational (arithmetic) intensity is fairly low, and the CPU uses data faster than it can be transferred from memory; in the latter case, data can be transferred more rapidly than it can be utilised.

A key premise of Devito is that arithmetic intensity can be decreased at the cost of higher memory pressure, by manipulating expressions~\cite{fabio-memory}.
Time-tiling reduces memory pressure by increasing reuse of cached data before it is evicted.
Accepting the premise that arithmetic intensity can be reduced sufficiently, time-tiling can be used to full effect in reducing memory pressure.\footnote{See Section~\ref{sec:roofline-intro} (``Roofline model'') for more detail.}
Therefore, we will mainly explore test cases which are already bound by memory throughput.

\subsection{Environment}
Evaluation was performed on a machine running Ubuntu 16.04 LTS, with all running services required either for the operating system or our evaluation, to minimise external effects on runtime.
The machine used an Intel Xeon E5-2470 at 2.30 GHz, with 8 cores and 16 threads, and had 64 GB of memory.

% TODO: cache?

To ensure a realistic testing environment and utilise all the available resources, the following hold throughout the experiments:

% TODO: what is openmp
\begin{itemize}
	\item OpenMP directives enabled in Devito. Indicates that a loop should be computed in parallel (typically the body of the inner time loop).
	\item OpenMP environment variable to utilise all 16 available threads.
	% TODO: cite
	\item OpenMP environment variable not to migrate threads (``thread pinning''), as well as allocate threads to different cores. Thread migration incurs a significant performance overhead, and parallelism would not help if all threads executed in serial on one core.
	\item Usage of the Intel C Compiler, \texttt{icc}.
	\item Devito enables the highest level of compiler optimisation and parallelism in the compiler by default.
\end{itemize}

\subsection{Use of auto-tuner}
% Usage of AT -- parameters (skewing factor, time and space tile sizes)
We were wary of assuming which tile sizes might be optimal for time-tiling, as they are not easily predicted from those optimal for spatial tiling or cache size~\cite{lam91}.
Therefore, the extended Devito auto-tuner (Section~\ref{sec:autotune}) was used to explore as many plausible tile sizes combinations as possible.

As detailed above, experimentation on the skewing factor was done manually.
An exhaustive search was performed, as the space was relatively small, and the effect on our stencils not well studied.

As a matter of expedience, the auto-tuner was run for at least 3 trials.
If these produced the same combination of tile sizes, this combination would be chosen as optimal, and run repeatedly to determine its runtime.
This obviated the need to run the (rather lengthy) auto-tuning for each data point.

\subsection{Functional correctness}
\label{sec:eval-func-corr}

% TODO: update when operator allows for t=64 without diverging
In addition to new test cases, to build confidence in correctness of the newly-implemented skewing and tiling transformations, each application of time-tiling was numerically verified against a non-tiled computation.

In all experiments, the results were discovered to be equal.\footnote{We refer to equality under floating-point comparison; this is \emph{bitwise equality}.}
Since floating-point arithmetic is non-associative, the natural implication is that the resulting value in each field was reached through the same expressions, although the computations had been re-ordered.
Additional checks were used to determine that the results were not merely zeroes, or diverging to infinity.

\subsection{Roofline model}
\label{sec:roofline-intro}


\subsection{Reporting of runtimes}
Wherever runtimes have been collected in this evaluation, the reported figure will be the \emph{minimum} of the runtimes collected in trials.
This is taken as most representative, as any noise on the testing machine is minimised, since outside factors can only increase the runtime of our computations.


\section{Performance under the Laplace operator}
\label{sec:perf-laplace}

\subsection{Application of the operator}
% Sample code from apply.py
% Insert perf1.py into appendix (invocation of the operator, testing rigour)

\subsection{Parameters}
\paragraph{Skewing factor}
The skewing factor was varied to understand the relationship between skewing factor and runtime.
In particular, we wished to determine if the minimum legal skewing factor would result in the minimum runtime as hypothesised.

\paragraph{Space order}
The space order of the computation determines the precision of the result.
In solving differential equations, is the order of the approximation, beyond which smaller terms are discarded.
A higher space order means each cell is computed using more of its neighbours, resulting in greater precision.
This would require a larger stencil, and hence a larger skewing factor.

\subsection{Results}
% Sample program output
% Performance figures -- the spreadsheet
% Percentage improvement over space-tiling
% Discuss peak memory bandwidth, benchmarked bandwidth, and how much Devito used
% Show that I am memory bounded, not cpu bounded -- ask TJ -- urgent

\subsection{Effect of the skewing factor}
% Discussion of skew factor


\section{Limitations of performance evaluation}
\label{sec:perf-limitations}
% "Why I could be wrong/this isn't representative of real world problems"

% Ask Paul/Fabio
% No time buffering, so not the same memory accesses
% Only ran X trials
% Didn't run vtune, can't prove -why- we're faster. See Dylan 6.7


\section{Further evaluation}
\label{sec:further-eval}

% Bigger time tiles
% Time buffering (since we store everything to verify)
% More grid sizes!
% Run vtune
% Try more stencils (eqns etc)
% Try bigger grids


\section{Conclusion}
\label{sec:eval-conclusion}


\paragraph{BREAK}
Everything that follows here is old.

Previous evaluation suggested that Devito gains considerable speedup from time-tiling.
This chapter focusses on evaluating this statement with general time-tiling implemented in Devito.

\paragraph{Objective}
We want to evaluate the performance of the time-tiling transformation against that of tiling only in the other dimensions.


\section{Functional correctness}
This will be done primarily using test cases, some of which have already been written to test the features already implemented.
Where possible, existing test cases are reused, when the output is expected not to vary.

Additionally, while Devito is targeted at seismic imaging, it can also be used to apply finite-difference methods to general differential equations.
We are therefore able to perform testing against many natural examples, rather than being dependent on hand-crafted stencils.


\section{Initial performance evaluation}
The initial evaluation was completed using a machine in the Department of Computing Student Lab (\texttt{graphic12}).
We used an iteration space of dimensions \(384^3\) under a Laplacian operator, larger than the cache size to ensure that the tiling functionality was utilised.
A 30.7\% decrease in runtime was recorded with the Intel C++ Compiler (31.5\% under GCC) over 30 runs.

We will perform evaluation against a variety of stencils, including the acoustic wave equation (AWE) stencil used in~\cite{dylan}.
In all cases, consideration will be necessary to deal with time-dimension buffering.
This evaluation would comprise both timing and memory usage, as well as examining the loop structures of the generated code.

For a more in depth analysis, we would consider memory analyses measuring cache misses and memory traffic, to ensure that improvements are indeed gleaned from time-tiling rather than other factors.


\section{Extended evaluation}
As mentioned above, Devito gives rise to many natural test cases.
Implementation and time permitting, we could evaluate the benefit of time-tiling against a plethora of problems, such as inversion, or other operator orderings.
